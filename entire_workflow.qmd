---
title: "Thesis - Import Files"
toc: true
number-sections: true
format: gfm
warning: false
output: false
error: true
editor_options: 
  markdown: 
    wrap: sentence
---

# Setup

# Load libraries

```{r}
library(tidyverse)
library(readxl)
# library(httr)
# library(rvest)
# locale("he")
```

# Utility functions

```{r}
get_file_ext <- function(string) {
  str_c(".", str_extract(string, "[0-9a-z]+$"))
}
```

```{r}
fix_names <- function(data, row_num, fill_missing) {
  data <- data |> 
    slice(row_num) |> 
    pivot_longer(everything()) |> 
    select(value)
  
  if (fill_missing) {
    data <- data |> 
      fill(value)
  }
  else {
    data <- data |> 
      replace_na(list(value = "")) |> 
      mutate(
        value = if_else(
          str_length(value) > 0,
          str_c(" ", value),
          value
        )
      )
  }
  data |> 
    pull(value)
}
```


```{r}
merge_names <- function(data, names_num = 2, fill_missing = TRUE) {
  rows <- seq(names_num)
  col_names_merged <- map2(
    rows,
    fill_missing,
    \(i, fill_missing) fix_names(data, row_num = i, fill_missing)
  ) |> 
    bind_cols() |> 
    unite(col = "var_names", sep = "") |> 
    pull(var_names)

  data <- data |>
    slice(-rows)
  
  names(data) <- col_names_merged
  
  data
}
```


# Municipalities data

## Import a single municipalities file from CBS (2016 and later)

This is a function that gets a path and returns a tibble.
First, it creates a temporary file: it either downloads the file with the path parameter as url, or uses the local path.
later, it reads the two lines of names of variables and handles each one of them separately.
The upper row gets filled with previous variable names for NAs because of merged cells in the original table.
The lower row gets blank string for NAs.
When concatenating, if there is a second argument for the variable, the variable name gets padded with blank space between its two arguments.

```{r}
read_muni_new <- function(path, is_online = FALSE) {
  if (is_online)
    GET(path, write_disk(path <- tempfile(fileext = get_file_ext(path))))
  
  df_head <- read_excel(path, sheet = 2, skip = 3, n_max = 2, col_names = FALSE)
  
  col_names_1 <- df_head |> 
    slice(1) |> 
    pivot_longer(everything()) |> 
    select(value) |> 
    fill(value)
  
  col_names_2 <- df_head |> 
    slice(2) |> 
    pivot_longer(everything()) |> 
    select(value) |> 
    replace_na(list(value = ""))
  
  df_col_names <- bind_cols(col_names_1, col_names_2) |> 
    mutate(
      col_names_merged = if_else(
        str_length(value...2) > 0,
        str_c(value...1, value...2, sep = " "),
        str_c(value...1, value...2)
      )
    )
  
  col_names_merged <- df_col_names |> 
    pull(col_names_merged)
  
  read_excel(path, sheet = 2, skip = 5, col_names = col_names_merged)
}

```

## Import a single municipalities file from CBS (2015 and before) with a single variable
This function is important because some SELA data is using population data older than 2018.
This function takes the url of the file, the wanted column numbers for the cities and for the regional councils.
It returns a tibble with a municipality id and the wanted variable values.
```{r}
read_muni_old <- function(url, col_num_1, col_num_2){
  GET(url, write_disk(tf <- tempfile(fileext = get_file_ext(url))))  
  
  df1 <- read_excel(tf, sheet = 2, skip = 1)
  df2 <- read_excel(tf, sheet = 4, skip = 1)
  
  df1 <- df1 %>% 
    select(
      muni_id = 2,
      var = col_num_1
    ) %>% 
    filter(str_length(muni_id) == 4)
  
  df2 <- df2 %>% 
    select(
      muni_id = 2,
      var = col_num_2
    ) %>% 
    filter(str_length(muni_id) == 2)
  
  df <- bind_rows(df1, df2)
  df
}
```
