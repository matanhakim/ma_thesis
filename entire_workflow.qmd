---
title: "Thesis - Import Files"
toc: true
number-sections: true
format: gfm
warning: false
output: false
error: true
editor_options: 
  markdown: 
    wrap: sentence
---

# Setup

## Load libraries

```{r}
library(conflicted)
library(tidyverse)
library(readxl)
library(httr)
# library(rvest)
# locale("he")
```
## Library conflicts
```{r}
conflicts_prefer(dplyr::filter())
```



# Utility functions

This function finds the file extension of a file.
It receives a string as an argument, and returns the last letters and numbers of the string, prefixed by a dot (`.`).
This helps to identify the file type from a file path, mainly used to write temporary files to disk when reading Excel files.

```{r}
get_file_ext <- function(string) {
  str_c(".", str_extract(string, "[0-9a-z]+$"))
}
```

This function reads an Excel file from a url online.
It receives a url and other arguments used by `read_excel()`, and returns the tibble after being read.

```{r}
read_excel_url <- function(url, ...) {
  GET(url, write_disk(tf <- tempfile(fileext = get_file_ext(url))))
  read_excel(tf, ...)
}
```


This function helps to fix column names of Excel tables, mainly of the form of those found in Israeli CBS municipality data.
It does so by fixing a single row of to-be column names.
It receives a data frame, an integer number representing a single row considered as holding (some of the) variable names, and a logical length-one vector specifying whether to fill missing values with preceding values or not.
This last argument is mostly used in the case of merged cells in Excel files.
The function first transposes the row, and then either fills it with values or turns NAs to empty strings.

```{r}
fix_names <- function(data, row_num, fill_missing) {
  data <- data |> 
    slice(row_num) |> 
    pivot_longer(everything()) |> 
    select(value)
  
  if (fill_missing) {
    data <- data |> 
      fill(value)
  }
  else {
    data <- data |> 
      replace_na(list(value = "")) |> 
      mutate(
        value = if_else(
          str_length(value) > 0,
          str_c(" ", value),
          value
        )
      )
  }
  data |> 
    pull(value)
}
```

This function fixes column names of Excel tables, mainly of the form of those found in Israeli CBS municipality data.
It receives a data frame, a vector with the row numbers considered as holding the variable names, and a logical vector specifying whether to fill missing values with preceding values or not.
This last argument should be either of length 1, or of length of `row_num`.
It is mostly used in the case of merged cells in Excel files.
The function saves the new column names by iterating over every row, fixing the variable names, binding all names to a single tibble, uniting the different columns to a single column and pulling these values as a vector. The old rows containing these column names are filtered out, and the new merged and fixed names are set to the data frame, which is then returned.



```{r}
merge_names <- function(data, names_num = 2, fill_missing = TRUE) {
  rows <- seq(names_num)
  col_names_merged <- map2(
    rows,
    fill_missing,
    \(i, fill_missing) fix_names(data, row_num = i, fill_missing)
  ) |> 
    bind_cols() |> 
    unite(col = "var_names", sep = "") |> 
    pull(var_names)

  data <- data |>
    slice(-rows)
  
  names(data) <- col_names_merged
  
  data
}
```

```{r}
fix_yishuv_id <- function(yishuv_id) {
  str_pad(yishuv_id, width = 4, side = "left", pad = "0")
}
```


# Municipalities data

## Import a single municipalities file from CBS (2016 and later)

This is a function that gets a path and returns a tibble.
First, it creates a temporary file: it either downloads the file with the path parameter as url, or uses the local path.
later, it reads the two lines of names of variables and handles each one of them separately.
The upper row gets filled with previous variable names for NAs because of merged cells in the original table.
The lower row gets blank string for NAs.
When concatenating, if there is a second argument for the variable, the variable name gets padded with blank space between its two arguments.
Finally, these column names are added to the tibble. The tibble is read again to ensure good guessing of column types.

```{r}
read_muni_new <- function(path, is_online = FALSE) {
  if (is_online)
    GET(path, write_disk(path <- tempfile(fileext = get_file_ext(path))))
  
  col_names_merged <- read_excel(path, sheet = 2, skip = 3, n_max = 2, col_names = FALSE) |> 
    merge_names(names_num = 2, fill_missing = c(TRUE, FALSE)) |> 
    names()
  
  read_excel(path, sheet = 2, skip = 5, col_names = col_names_merged)
}

df <- read_muni_new("data_files/municipalities/2018.xlsx")

```

## Import a single variable from a CBS municipalities file (2015 and before) with a single variable
This function is important because some SELA data is using population data older than 2018.
This function takes the url of the file, the wanted column numbers for the cities and for the regional councils.
It returns a tibble with a municipality id and the wanted variable values.
```{r}
read_muni_old_var <- function(path, var_name, col_num_1, col_num_2, is_online = FALSE) {
  if(is_online)
    GET(path, write_disk(path <- tempfile(fileext = get_file_ext(path))))  
  
  df1 <- read_excel(path, sheet = 2, skip = 1)
  df2 <- read_excel(path, sheet = 4, skip = 1)
  
  df1 <- df1 |> 
    select(
      muni_id = 2,
      var = all_of(col_num_1)
    ) |> 
    filter(str_length(muni_id) == 4)
  
  df2 <- df2 |> 
    select(
      muni_id = 2,
      var = all_of(col_num_1)
    ) |> 
    filter(str_length(muni_id) == 2)
  
  bind_rows(df1, df2) |> 
    rename("{{ var_name }}" := var)
}

# df_2 <- read_muni_old_var("data_files/municipalities/2013.xls", mahoz, 3, 3)

```
# Municipality id

Every municipality has different ids for different authorities. This function reads the requested ids and includes their names if requested.

```{r}
read_muni_id <- function(id_types = c("cbs", "edu", "tax"), include_names = FALSE) {

  data <- read_csv("https://raw.githubusercontent.com/matanhakim/general_files/main/muni_ids.csv", col_types = cols(.default = "c"))
    
  if (include_names)
  {
    data |> 
      select(contains(id_types))
  }
  else
  {
    data |> 
      select(contains(id_types) & ends_with("id"))
  }
}
```


## Yishuvim

This function reads a specific variable from the yishuvim data, alongside its yishuv id.

```{r}
read_yishuv <- function(var_name, col_num) {
  yishuvim <- read_excel("data_files/yishuvim/bycode2021.xlsx", col_types = "text")
  
  yishuvim <- yishuvim |> 
    select(
      yishuv_id = 2,
      {{ var_name }} := all_of(col_num)
    ) |> 
    mutate(
      yishuv_id = fix_yishuv_id(yishuv_id)
    )
  
yishuvim
}
```

This is a specific function that matches yishuv and municipality id.

```{r}
match_yishuv_muni <- function() {
  
  read_yishuv(muni_id, 9) |> 
    mutate(
      muni_id = case_when(
        (muni_id == "0" | muni_id == "99") ~ yishuv_id,
        TRUE ~ str_pad(muni_id, width = 2, side = "left", pad = "0")
      )
    )
}
```

# Elections data

This function reads the raw 2015 elections data file and adds a municipality id for every yishuv.

```{r}
read_elect_muni <- function() {
  read_excel("data_files/elections/results_20.xls") |> 
    rename(yishuv_id = 2) |> 
    mutate(yishuv_id = fix_yishuv_id(yishuv_id)) |> 
    left_join(match_yishuv_muni(), join_by(yishuv_id))
}
```

This function computes voting percentages for Likud and coalition parties in every municipality. It filters out NA values (like Beduin tribes). In 2015, there were no voting in Ein Kinya.

```{r}
get_elect_pct <- function(){
  
  read_elect_muni() |>  
    rename(
      pot_votes = 4,
      good_votes = 7,
      yahadut_hatorah = 9,
      habait_hayehudi = 14,
      kulanu = 19,
      israel_beytenu = 20,
      halikud = 21,
      shas = 33
    ) |> 
    group_by(muni_id) |> 
    summarize(
      likud_pct = 100 * sum(halikud) / sum(good_votes),
      coal_pct = 100 * sum(
        yahadut_hatorah +
        habait_hayehudi +
        kulanu +
        israel_beytenu +
        halikud +
        shas
      ) / sum(good_votes),
      pot_votes = sum(pot_votes),
      good_votes = sum(good_votes)
    ) |> 
    filter(!is.na(muni_id))
}
```

# Budget data

## Sela

This function reads SELA budget by the ministry of culture from the years 2016-2019.

```{r}
read_sela_budget <- function() {
  
  read_excel("data_files/budget/תמיכות המשרד לגופי תרבות 2016-2019.xlsx", sheet = 39) |> 
    slice(-1) |> 
    select(
      tax_id = 1,
      # tax_name = 2,
      init_2016 = 3,
      fest_2016 = 4,
      sela_2016 = 5,
      init_2017 = 7,
      fest_2017 = 8,
      sela_2017 = 9,
      init_2018 = 11,
      fest_2018 = 12,
      sela_2018 = 13,
      init_2019 = 15,
      fest_2019 = 16,
      sela_2019 = 17
    ) |> 
    pivot_longer(!tax_id, names_to = c("budget_type", "year"), names_sep = "_", values_to = "budget") |> 
    replace_na(list(budget = 0)) |> 
    mutate(
      year = as.numeric(year)
      ) |> 
    pivot_wider(names_from = "budget_type", names_prefix = "budget_approved_", values_from = "budget") |> 
    left_join(read_muni_id(c("tax", "cbs")), join_by(tax_id)) |> 
    select(
      muni_id = cbs_id,
      !tax_id
    )
}
```

## Culture (total)

```{r}
read_culture_budget <- function() {
  read_csv("data_files/budget/מינהל התרבות__ פירוט כל התמיכות מתקציב זה שאושרו ב כל השנים.csv") |> 
    select(
      tax_id = 6,
      year = 7,
      budget_approved_culture = 8,
      budget_paid_culture = 9
    ) |> 
    replace_na(
      list(budget_approved_culture = 0, budget_paid_culture = 0)
    ) |> 
    mutate(tax_id = as.character(tax_id)) |> 
    summarise(
      .by = c(tax_id, year),
      budget_approved_culture = sum(budget_approved_culture),
      budget_paid_culture = sum(budget_paid_culture)
    )
}
```

