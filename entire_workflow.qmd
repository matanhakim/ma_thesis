---
title: "Thesis - Import Files"
toc: true
number-sections: true
format: gfm
warning: false
output: false
error: true
editor_options: 
  markdown: 
    wrap: sentence
---

# Setup

## Load libraries

```{r}
library(conflicted)
library(tidyverse)
library(readxl)
library(httr)
# library(rvest)
# locale("he")
```
## Library conflicts
```{r}
conflicts_prefer(dplyr::filter())
```



# Utility functions

This function finds the file extension of a file.
It receives a string as an argument, and returns the last letters and numbers of the string, prefixed by a dot (`.`).
This helps to identify the file type from a file path, mainly used to write temporary files to disk when reading Excel files.

```{r}
get_file_ext <- function(string) {
  str_c(".", str_extract(string, "[0-9a-z]+$"))
}
```

This function reads an Excel file from a url online.
It receives a url and other arguments used by `read_excel()`, and returns the tibble after being read.

```{r}
read_excel_url <- function(url, ...) {
  GET(url, write_disk(tf <- tempfile(fileext = get_file_ext(url))))
  read_excel(tf, ...)
}
```


This function helps to fix column names of Excel tables, mainly of the form of those found in Israeli CBS municipality data.
It does so by fixing a single row of to-be column names.
It receives a data frame, an integer number representing a single row considered as holding (some of the) variable names, and a logical length-one vector specifying whether to fill missing values with preceding values or not.
This last argument is mostly used in the case of merged cells in Excel files.
The function first transposes the row, and then either fills it with values or turns NAs to empty strings.

```{r}
fix_names <- function(data, row_num, fill_missing) {
  data <- data |> 
    slice(row_num) |> 
    pivot_longer(everything()) |> 
    select(value)
  
  if (fill_missing) {
    data <- data |> 
      fill(value)
  }
  else {
    data <- data |> 
      replace_na(list(value = "")) |> 
      mutate(
        value = if_else(
          str_length(value) > 0,
          str_c(" ", value),
          value
        )
      )
  }
  data |> 
    pull(value)
}
```

This function fixes column names of Excel tables, mainly of the form of those found in Israeli CBS municipality data.
It receives a data frame, a vector with the row numbers considered as holding the variable names, and a logical vector specifying whether to fill missing values with preceding values or not.
This last argument should be either of length 1, or of length of `row_num`.
It is mostly used in the case of merged cells in Excel files.
The function saves the new column names by iterating over every row, fixing the variable names, binding all names to a single tibble, uniting the different columns to a single column and pulling these values as a vector. The old rows containing these column names are filtered out, and the new merged and fixed names are set to the data frame, which is then returned.



```{r}
merge_names <- function(data, names_num = 2, fill_missing = TRUE) {
  rows <- seq(names_num)
  col_names_merged <- map2(
    rows,
    fill_missing,
    \(i, fill_missing) fix_names(data, row_num = i, fill_missing)
  ) |> 
    bind_cols() |> 
    unite(col = "var_names", sep = "") |> 
    pull(var_names)

  data <- data |>
    slice(-rows)
  
  names(data) <- col_names_merged
  
  data
}
```

```{r}
fix_yishuv_id <- function(yishuv_id) {
  str_pad(yishuv_id, width = 4, side = "left", pad = "0")
}
```

```{r}
clean_yishuv_name <- function(yishuv_name) {
  yishuv_name |> 
    str_remove_all("[[:punct:][:symbol:][:digit:]&&[^'\\-()\"]]") |> 
    str_squish()
}
```


# Municipalities data

## Import a single municipalities file from CBS (2016 and later)

This is a function that gets a path and returns a tibble.
First, it creates a temporary file: it either downloads the file with the path parameter as url, or uses the local path.
later, it reads the two lines of names of variables and handles each one of them separately.
The upper row gets filled with previous variable names for NAs because of merged cells in the original table.
The lower row gets blank string for NAs.
When concatenating, if there is a second argument for the variable, the variable name gets padded with blank space between its two arguments.
Finally, these column names are added to the tibble. The tibble is read again to ensure good guessing of column types.

```{r}
read_muni_new <- function(path, is_online = FALSE) {
  if (is_online)
    GET(path, write_disk(path <- tempfile(fileext = get_file_ext(path))))
  
  col_names_merged <- read_excel(path, sheet = 2, skip = 3, n_max = 2, col_names = FALSE) |> 
    merge_names(names_num = 2, fill_missing = c(TRUE, FALSE)) |> 
    names()
  
  read_excel(path, sheet = 2, skip = 5, col_names = col_names_merged)
}

df_2018 <- read_muni_new("data/municipalities/2018.xlsx")

```

## Import a single variable from a CBS municipalities file (2016 and later) with a single variable

```{r}
read_muni_new_var <- function(path, var_name, col_num, is_online = FALSE) {
  if(is_online)
    GET(path, write_disk(path <- tempfile(fileext = get_file_ext(path))))  
  
  read_excel(path, sheet = 2, skip = 5, col_names = FALSE) |> 
  select(
    muni_id = 2,
    "{var_name}" := all_of(col_num)
  )
}
```


## Import a single variable from a CBS municipalities file (2015 and before) with a single variable
This function is important because some SELA data is using population data older than 2018.
This function takes the url of the file, the wanted column numbers for the cities and for the regional councils.
It returns a tibble with a municipality id and the wanted variable values.
```{r}
read_muni_old_var <- function(path, var_name, col_num_1, col_num_2, skip_rows = 1, is_online = FALSE) {
  if(is_online)
    GET(path, write_disk(path <- tempfile(fileext = get_file_ext(path))))  
  
  df1 <- read_excel(path, sheet = 2, skip = skip_rows)
  df2 <- read_excel(path, sheet = 4, skip = skip_rows)
  
  df1 <- df1 |> 
    select(
      muni_id = 2,
      "{var_name}" := all_of(col_num_1)
    ) |> 
    filter(str_length(muni_id) == 4)
  
  df2 <- df2 |> 
    select(
      muni_id = 2,
      "{var_name}" := all_of(col_num_2)
    ) |> 
    filter(str_length(muni_id) == 2)
  
  bind_rows(df1, df2) 
}

```

## Municipality id

Every municipality has different ids for different authorities. This function reads the requested ids and includes their names if requested.

```{r}
read_muni_id <- function(id_types = c("cbs", "edu", "tax"), include_names = FALSE) {

  data <- read_csv("https://raw.githubusercontent.com/matanhakim/general_files/main/muni_ids.csv", col_types = cols(.default = "c"))
    
  if (include_names)
  {
    data |> 
      select(contains(id_types))
  }
  else
  {
    data |> 
      select(contains(id_types) & ends_with("id"))
  }
}
```


## Yishuvim

This function reads a specific variable from the yishuvim data, alongside its yishuv id.

```{r}
read_yishuv <- function(var_name, col_num) {
  yishuvim <- read_excel("data/yishuvim/bycode2021.xlsx", col_types = "text")
  
  yishuvim <- yishuvim |> 
    select(
      yishuv_id = 2,
      {{ var_name }} := all_of(col_num)
    ) |> 
    mutate(
      yishuv_id = fix_yishuv_id(yishuv_id)
    )
  
yishuvim
}
```

This is a specific function that matches yishuv and municipality id.

```{r}
match_yishuv_muni <- function() {
  
  read_yishuv(muni_id, 9) |> 
    mutate(
      muni_id = case_when(
        (muni_id == "0" | muni_id == "99") ~ yishuv_id,
        TRUE ~ str_pad(muni_id, width = 2, side = "left", pad = "0")
      )
    )
}
```

This function reads all possible names for yishuvim and their CBS yishuv id.

```{r}
read_yishuv_names <- function() {
  read_csv(
    "https://raw.githubusercontent.com/matanhakim/general_files/main/yishuv_names.csv",
    col_types = cols(.default = "c")
  )
}
```


## 2013 CBS SES data

This function reads the 2013 CBS SES data for municipalities that is being used by 2018 SELA regulations to determine eligibility of municipalities.
It reads the file, selects the relevant variables, removes excess rows, and transforms the id to the usual format.

```{r}
read_ses_2013 <- function(url) {
  
  read_excel("data/municipalities/t02.xls", skip = 6) |> 
    slice(2:256) |>
    select(
      muni_status = 1,
      muni_id = 2,
      ses_2013_i = 5,
      ses_2013_r = 6,
      ses_2013_c = 7
    ) |> 
    mutate(
      muni_id = as.character(muni_id),
      muni_id = case_when(
        (muni_status == "0" | muni_status == "99") ~ str_pad(muni_id, width = 4, side = "left", pad = "0"),
        TRUE ~ str_pad(muni_status, width = 2, side = "left", pad = "0")
      )
    ) |> 
    select(!muni_status)
}
```

## 2004 CBS periphery data

Important to note that this is and old indicator, therefore since then some municipal jurisdiction changes have happened:

```{r}
read_peri_2004 <- function() {
  
  read_excel("data/municipalities/24_08_160t2.xls", skip = 7) |> 
    select(
      muni_id = 1,
      peri_2004_i = 9,
      peri_2004_r = 10,
      peri_2004_c = 11
    ) |> 
    mutate(
      muni_id = as.character(muni_id),
      muni_id = case_when(
        str_length(muni_id) == 5 ~ str_sub(muni_id, start = -2),
        TRUE ~ str_pad(muni_id, width = 4, side = "left", pad = "0")
      )
    )
}
```

# Elections data

This function reads the raw 2015 elections data file and adds a municipality id for every yishuv.

```{r}
read_elect_muni <- function() {
  read_excel("data/elections/results_20.xls") |> 
    rename(yishuv_id = 2) |> 
    mutate(yishuv_id = fix_yishuv_id(yishuv_id)) |> 
    left_join(match_yishuv_muni(), join_by(yishuv_id))
}
```

This function computes voting percentages for Likud and coalition parties in every municipality. It filters out NA values (like Beduin tribes). In 2015, there were no voting in Ein Kinya.

```{r}
get_elect_pct <- function() {
  
  read_elect_muni() |>  
    rename(
      pot_votes = 4,
      good_votes = 7,
      yahadut_hatorah = 9,
      habait_hayehudi = 14,
      kulanu = 19,
      israel_beytenu = 20,
      halikud = 21,
      shas = 33
    ) |> 
    group_by(muni_id) |> 
    summarize(
      likud_pct = 100 * sum(halikud) / sum(good_votes),
      coal_pct = 100 * sum(
        yahadut_hatorah +
        habait_hayehudi +
        kulanu +
        israel_beytenu +
        halikud +
        shas
      ) / sum(good_votes),
      pot_votes = sum(pot_votes),
      good_votes = sum(good_votes)
    ) |> 
    filter(!is.na(muni_id))
}
```

# Organizations data

## Amutot

This function reads every registered amuta from guidestar and returns its organiztion (tax) id and the name of its registered yishuv
```{r}
read_amutot <- function() {
  
  df_amutot_new <- read_excel("data/organizations/דוח חודשי גיידסטאר.xlsx", sheet = 2) |> 
    select(
      tax_id = 2,
      yishuv_name = 14
    ) |> 
    mutate(
      tax_id = as.character(tax_id),
      yishuv_name = clean_yishuv_name(yishuv_name)
    )
  
  df_amutot_old <- read_excel("data/organizations/דוח גיידסטאר - אוגוסט 2020.xlsx") |> 
    select(
      tax_id = 2,
      yishuv_name = 28
    ) |> 
    mutate(
      tax_id = as.character(tax_id),
      yishuv_name = clean_yishuv_name(yishuv_name)
    )
  
  bind_rows(
    df_amutot_new,
    df_amutot_old
  ) |> 
    arrange(tax_id, yishuv_name) |> 
    distinct(tax_id, .keep_all = TRUE)
}
```

## Companies

```{r}
read_companies <- function() {
  read_csv("data/organizations/companies.csv") |> 
    select(
      tax_id = 1,
      yishuv_name = 13
    ) |> 
    filter(!is.na(yishuv_name)) |> 
    mutate(
      tax_id = as.character(tax_id),
      yishuv_name = clean_yishuv_name(yishuv_name)
    )
}
```

## Municipalities

```{r}
read_muni_names <- function() {
  read_muni_id(include_names = TRUE) |> 
    select(!c(edu_id, cbs_id)) |> 
    pivot_longer(!tax_id, names_to = "var", values_to = "yishuv_name") |> 
    select(!var) |> 
    distinct(yishuv_name, .keep_all = TRUE)
}
```


## Organiztions with no record
```{r}
read_organizations_bad_names <- function() {
  tibble(
    tax_id = c(
      "589931187", # אוניברסיטת תל אביב
      "500701628", # אוניברסיטת חיפה
      "580303808", # תזמורת יד חריף (צרעה)
      "580503605", # תזמורת נתיה הקאמרית הקיבוצית
      "510101819", # חברת נכון בע"מ (חיפה) 
      "589120880", # המרכז לאמנות יהודית רוסית (תל אביב)
      "511854788", # מתנס רמת נגב
      "512103383", # תאטרון ענתות (ראשון לציון)
      "510021298", # סול בעמ ( לא ידוע)
      "501501183", # ועדה מוניציפאלית חברון
      "510318652", # מקיצי נרדמים בעמ ( תל אביב)
      "510550767", # לאובק חיפה
      "500217229", # מגדל תפן
      "580409449", # עמותת יוצאי טורקיה בישראל (יהוד-מונוסון)
      "510356777", # המכון לתרגום ספרות עברית (תל אביב)
      "580270858", # פורום עולים ידידות (חולון)
      "510497464", # התאטרון הפתוח בעמ (תל אביב)
      "580374270", # אמנות המשחק לתיאטרון ולקולנוע
      "580070845", # מרכז זלמן שזר (ירושלים)
      "580510097", # להקת המחול מוריה קונג (תל אביב)
      "580520229", # אקס טריטוריה (תל אביב)
      "580114965", # כת עת אל-שרק (שפרעם)
      "580373777", # אנסמבל תיאטרון הרצליה
      "500500962", # יד יצחק בן-צבי (ירושלים)
      "580302909" # תאיר - מרכז לתרבות יהודית (תל אביב)
    ),
    yishuv_name = c(
      "תל אביב - יפו",
      "חיפה",
      "צרעה",
      "נתניה",
      "חיפה",
      "תל אביב - יפו",
      "רמת נגב",
      "ראשון לציון",
      NA,
      "חברון",
      "תל אביב - יפו",
      "חיפה",
      "מגדל תפן",
      "יהוד-מונוסון",
      "תל אביב - יפו",
      "חולון",
      "תל אביב - יפו",
      "תל אביב - יפו",
      "ירושלים",
      "תל אביב - יפו",
      "תל אביב - יפו",
      "שפרעם",
      "הרצליה",
      "ירושלים",
      "תל אביב - יפו"
    )
  )
}
```


## Match yishuv id to organizations

```{r}
read_organizations <- function() {
  bind_rows(
    read_amutot(),
    read_companies(),
    read_muni_names(),
    read_organizations_bad_names()
  ) |> 
    arrange(tax_id, yishuv_name) |> 
    distinct(tax_id, .keep_all = TRUE) |> 
    left_join(read_yishuv_names(), join_by(yishuv_name))
}
```


# Budget data

## Sela

This function reads SELA budget by the ministry of culture from the years 2016-2019.

```{r}
read_sela_budget <- function() {
  
  read_excel("data/budget/תמיכות המשרד לגופי תרבות 2016-2019.xlsx", sheet = 39) |> 
    slice(-1) |> 
    select(
      tax_id = 1,
      # tax_name = 2,
      init_2016 = 3,
      fest_2016 = 4,
      sela_2016 = 5,
      init_2017 = 7,
      fest_2017 = 8,
      sela_2017 = 9,
      init_2018 = 11,
      fest_2018 = 12,
      sela_2018 = 13,
      init_2019 = 15,
      fest_2019 = 16,
      sela_2019 = 17
    ) |> 
    pivot_longer(!tax_id, names_to = c("budget_type", "year"), names_sep = "_", values_to = "budget") |> 
    replace_na(list(budget = 0)) |> 
    mutate(
      year = as.numeric(year)
      ) |> 
    pivot_wider(names_from = "budget_type", names_prefix = "budget_approved_", values_from = "budget") |> 
    left_join(read_muni_id(c("tax", "cbs")), join_by(tax_id)) |> 
    select(
      muni_id = cbs_id,
      !tax_id
    )
}
```

## Culture (total)

This function reads the raw data from the Open Budget website of the ministry of culture, and summarizes it by year and organization.

```{r}
read_culture_budget <- function() {
  read_csv("data/budget/מינהל התרבות__ פירוט כל התמיכות מתקציב זה שאושרו ב כל השנים.csv") |> 
    select(
      tax_id = 6,
      year = 7,
      budget_approved_culture = 8,
      budget_paid_culture = 9
    ) |> 
    replace_na(
      list(budget_approved_culture = 0, budget_paid_culture = 0)
    ) |> 
    mutate(tax_id = as.character(tax_id)) |> 
    summarise(
      .by = c(tax_id, year),
      budget_approved_culture = sum(budget_approved_culture),
      budget_paid_culture = sum(budget_paid_culture)
    )
}
```

This chunk checks which organizations that got budget from the ministry of culture do not appear in the current organizations data.

```{r}
df_culture <- read_culture_budget() |> 
  left_join(read_organizations(), join_by(tax_id))

df_bad_names <- df_culture |> 
  filter(is.na(yishuv_id)) |> 
  distinct(yishuv_name, .keep_all = TRUE)
```


This function matches every organization supported by the ministry of culture with its municipality id. this leaves us with a municipality id for every budget support of the ministry of culture for every organization in every year. missing values include yishuvim not part of any municipality, like Mikveh Israel and the airport, and budgets that do not go to organiztions, mostly prizes for individuals.

```{r}
add_culture_budget_muni_id <- function() {
  df_culture <- read_culture_budget() |> 
    left_join(read_organizations(), join_by(tax_id)) |> 
    left_join(match_yishuv_muni(), join_by(yishuv_id)) |> 
    mutate(
      muni_id = case_when(
        !is.na(muni_id) ~ muni_id,
        str_length(yishuv_id) == 2 ~ yishuv_id
      )
    )
}
```

This function summarizes the cultural budget data by municipality and year.

```{r}
culture_budget_by_muni <- function() {
  add_culture_budget_muni_id() |> 
    summarise(
      .by = c(year, muni_id),
      budget_approved_culture = sum(budget_approved_culture),
      budget_paid_culture = sum(budget_paid_culture)
    )
}
```

# Create a complete data frame

## Read population for every year

```{r}
df_pop_args_old <- tribble(
  ~path, ~var_name, ~col_num_1, ~col_num_2, ~skip_rows, ~year,
  "",    "pop",     15,          30,         0,         2013,
  "",    "pop",     16,          33,         1,         2014,
  "",    "pop",     14,          31,         1,         2015
) |> 
  mutate(
    path = str_c("data/municipalities/", year, ".xls")
  ) |> 
  select(!year)

df_pop_args_new <- tibble(
      path = str_c("data/municipalities/", 2016:2019, ".xlsx"),
      var_name = "pop",
      col_num = 13
    )
df_pop <- bind_rows(
  pmap(df_pop_args_old, read_muni_old_var),
  pmap(df_pop_args_new, read_muni_new_var)
) |> 
  mutate(
    year = rep(2013:2019, each = 255),
    pop = if_else(pop < 1000, pop * 1000, pop)
  )
```

## Classify municipalities to sector (Jewish/Arab)

```{r}
df_sector <- read_muni_new_var("data/municipalities/2019.xlsx", "arab_pct", 16) |> 
  mutate(
    arab_pct = as.numeric(str_replace(arab_pct, "-", "0")),
    sector = as_factor(if_else(arab_pct > 50, "arab", "jewish"))
  ) |> 
  select(!arab_pct)
```


## Combine all data frames

```{r}
df <- expand_grid(
  year = 2013:2019,
  read_muni_id(id_types = "cbs", include_names = TRUE)
) |> 
  rename(
    muni_id = cbs_id,
    muni_name = cbs_name
  ) |> 
  left_join(culture_budget_by_muni(), join_by(year, muni_id)) |> 
  left_join(read_sela_budget(), join_by(year, muni_id)) |> 
  mutate(across(contains("budget"), \(x) replace_na(x, 0))) |> 
  left_join(df_pop, join_by(year, muni_id)) |> 
  left_join(df_sector, join_by(muni_id))
```

