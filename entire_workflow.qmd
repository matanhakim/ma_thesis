---
title: "Thesis - Import Files"
toc: true
number-sections: true
format: gfm
warning: false
output: false
error: true
editor_options: 
  markdown: 
    wrap: sentence
---

# Setup

# Load libraries

```{r}
library(tidyverse)
library(readxl)
# library(httr)
# library(rvest)
# locale("he")
```

# Utility functions

This function finds the file extension of a file.
It receives a string as an argument, and returns the last letters and numbers of the string, prefixed by a dot (`.`).
This helps to identify the file type from a file path, mainly used to write temporary files to disk when reading Excel files.

```{r}
get_file_ext <- function(string) {
  str_c(".", str_extract(string, "[0-9a-z]+$"))
}
```

This function helps to fix column names of Excel tables, mainly of the form of those found in Israeli CBS municipality data.
It does so by fixing a single row of to-be column names.
It receives a data frame, an integer number representing a single row considered as holding (some of the) variable names, and a logical length-one vector specifying whether to fill missing values with preceding values or not.
This last argument is mostly used in the case of merged cells in Excel files.
The function first transposes the row, and then either fills it with values or turns NAs to empty strings.

```{r}
fix_names <- function(data, row_num, fill_missing) {
  data <- data |> 
    slice(row_num) |> 
    pivot_longer(everything()) |> 
    select(value)
  
  if (fill_missing) {
    data <- data |> 
      fill(value)
  }
  else {
    data <- data |> 
      replace_na(list(value = "")) |> 
      mutate(
        value = if_else(
          str_length(value) > 0,
          str_c(" ", value),
          value
        )
      )
  }
  data |> 
    pull(value)
}
```

This function fixes column names of Excel tables, mainly of the form of those found in Israeli CBS municipality data.
It receives a data frame, a vector with the row numbers considered as holding the variable names, and a logical vector specifying whether to fill missing values with preceding values or not.
This last argument should be either of length 1, or of length of `row_num`.
It is mostly used in the case of merged cells in Excel files.
The function saves the new column names by iterating over every row, fixing the variable names, binding all names to a single tibble, uniting the different columns to a single column and pulling these values as a vector. The old rows containg these column names are filtered out, and the new merged and fixed names are set to the data frame, which is then returned.



```{r}
merge_names <- function(data, names_num = 2, fill_missing = TRUE) {
  rows <- seq(names_num)
  col_names_merged <- map2(
    rows,
    fill_missing,
    \(i, fill_missing) fix_names(data, row_num = i, fill_missing)
  ) |> 
    bind_cols() |> 
    unite(col = "var_names", sep = "") |> 
    pull(var_names)

  data <- data |>
    slice(-rows)
  
  names(data) <- col_names_merged
  
  data
}
```


# Municipalities data

## Import a single municipalities file from CBS (2016 and later)

This is a function that gets a path and returns a tibble.
First, it creates a temporary file: it either downloads the file with the path parameter as url, or uses the local path.
later, it reads the two lines of names of variables and handles each one of them separately.
The upper row gets filled with previous variable names for NAs because of merged cells in the original table.
The lower row gets blank string for NAs.
When concatenating, if there is a second argument for the variable, the variable name gets padded with blank space between its two arguments.

```{r}
read_muni_new <- function(path, is_online = FALSE) {
  if (is_online)
    GET(path, write_disk(path <- tempfile(fileext = get_file_ext(path))))
  
  df_head <- read_excel(path, sheet = 2, skip = 3, n_max = 2, col_names = FALSE)
  
  col_names_1 <- df_head |> 
    slice(1) |> 
    pivot_longer(everything()) |> 
    select(value) |> 
    fill(value)
  
  col_names_2 <- df_head |> 
    slice(2) |> 
    pivot_longer(everything()) |> 
    select(value) |> 
    replace_na(list(value = ""))
  
  df_col_names <- bind_cols(col_names_1, col_names_2) |> 
    mutate(
      col_names_merged = if_else(
        str_length(value...2) > 0,
        str_c(value...1, value...2, sep = " "),
        str_c(value...1, value...2)
      )
    )
  
  col_names_merged <- df_col_names |> 
    pull(col_names_merged)
  
  read_excel(path, sheet = 2, skip = 5, col_names = col_names_merged)
}

```

## Import a single municipalities file from CBS (2015 and before) with a single variable
This function is important because some SELA data is using population data older than 2018.
This function takes the url of the file, the wanted column numbers for the cities and for the regional councils.
It returns a tibble with a municipality id and the wanted variable values.
```{r}
read_muni_old <- function(url, col_num_1, col_num_2){
  GET(url, write_disk(tf <- tempfile(fileext = get_file_ext(url))))  
  
  df1 <- read_excel(tf, sheet = 2, skip = 1)
  df2 <- read_excel(tf, sheet = 4, skip = 1)
  
  df1 <- df1 %>% 
    select(
      muni_id = 2,
      var = col_num_1
    ) %>% 
    filter(str_length(muni_id) == 4)
  
  df2 <- df2 %>% 
    select(
      muni_id = 2,
      var = col_num_2
    ) %>% 
    filter(str_length(muni_id) == 2)
  
  df <- bind_rows(df1, df2)
  df
}
```
